import{g as m}from"./index-1KR-OfoX.js";import{r as g,f as l}from"./vue-chunks-BSjLwu6d.js";class p{constructor(e,s){this.debug=s.debug||!1,this.socketOpen=!1,this.socketMsgQueue=[],this.heartbeatInterval=5*1e3,this.heartbeatTimer=null,this.disableHeartbeat=s.disableHeartbeat,this.disableReconnect=!1,this.reconnectAttempts=0,this.reconnectInterval=5*1e3,this.reconnectTimer=null,this.events={},this.url=e,this.ws=null,this.options=s,this.connect(),this.log=function(){},this.debug&&(this.log=console.log)}connect(){this.ws&&this.socketOpen||(this.ws=new WebSocket(this.url),this.ws.onopen=()=>{this.log("WebSocket open"),this.onOpen()},this.ws.onmessage=e=>{this.log("WebSocket message"),this.log(e),this.onMessage(e)},this.ws.onerror=e=>{this.log("WebSocket error"),this.log(e),this.onError(e)},this.ws.onclose=e=>{this.log("WebSocket closed"),this.log(e),this.onClose(e)})}onOpen(){this.socketOpen=!0,this.reconnectAttempts=0,this.disableReconnect=!1,this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null),this.sendHeartBeat();for(var e=0;e<this.socketMsgQueue.length;e++)this.send(this.socketMsgQueue[e]);this.socketMsgQueue=[],this.emit("open")}onMessage(e){e&&e.data==="ping"?this.pong(e):this.emit("message",JSON.parse(e.data))}onError(e){this.emit("error",e)}onClose(e){this.emit("close",e),this.ws=null,this.socketOpen=!1,this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null),this.stopHeartBeat(),this.shouldReconnect()&&!this.disableReconnect&&this.reconnect()}send(e){this.ws&&this.socketOpen?this.ws.send(JSON.stringify(e)):this.socketMsgQueue.push(e)}pong(){this.ws.send("pong")}sendHeartBeat(){this.disableHeartbeat||(clearTimeout(this.heartbeatTimer),this.heartbeatTimer=setTimeout(()=>{this.send({type:"ping"}),this.sendHeartBeat(),this.emit("ping")},this.heartbeatInterval))}stopHeartBeat(){this.disableHeartbeat||clearTimeout(this.heartbeatTimer)}shouldReconnect(){const e=this.options.maxReconnectAttempts||1/0;return this.reconnectAttempts<e}reconnect(){this.reconnectTimer||(this.disableReconnect=!1,this.reconnectAttempts++,this.reconnectTimer=setTimeout(()=>{this.ws?(this.ws.close(),this.socketOpen=!1,this.ws=null):this.connect()},this.reconnectInterval))}close(e=!0){this.disableReconnect=e,this.reconnectTimer&&clearTimeout(this.reconnectTimer),this.ws&&this.ws.close()}emit(e,...s){this.events&&Array.isArray(this.events[e])&&this.events[e].forEach(o=>o(...s))}on(e,s){this.events||(this.events={}),this.events[e]||(this.events[e]=[]),this.events[e].push(s)}off(e,s){if(this.events&&Array.isArray(this.events[e]))if(!s)this.events[e]=[];else{const o=this.events[e].indexOf(s);o!==-1&&this.events[e].splice(o,1)}}}const a=l(null),n=l(null),i=g({}),w=()=>{async function c(t,r){let h=await m({openid:t});h&&(a.value=h.data.ws_url),n.value&&n.value.close(),n.value=new p(a.value,{disableHeartbeat:!0}),r&&r(),n.value.on("message",f=>{s("message",f)}),n.value.on("error",o)}function e(t,r){i[t]||(i[t]=[]),i[t].push(r)}function s(t,...r){i&&Array.isArray(i[t])&&i[t].forEach(h=>h(...r))}function o(t){}function u(){Object.keys(i).forEach(t=>{i[t]=[],delete i[t]}),n.value&&n.value.close()}return{connect:c,on:e,close:u}};export{w as u};
